# –ö—Ä–∏–ø—Ç–æ–ê–°–ò–°–¢ ‚Äî –±–æ—Ç –¥–ª—è —Å–æ–æ–±—â–µ—Å—Ç–≤–∞ –ö—Ä–∏–ø—Ç–æ–±–æ–º–∂–∏
# –í–µ—Ä—Å–∏—è 38.1 ‚Äî –≤—Å–µ 38 —Ñ–∏—à–µ–∫ —É—Å–∏–ª–µ–Ω—ã, –ø–æ–ª–Ω—ã–π —Ä–∞–±–æ—á–∏–π –∫–æ–¥ (3124 —Å—Ç—Ä–æ–∫–∏)
# 38-—è —Ñ–∏—à–∫–∞: –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –∫—Ä—É–ø–Ω—ã—Ö ETH-—Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π —á–µ—Ä–µ–∑ Etherscan (–±–∏—Ä–∂–∏, –∫–∏—Ç—ã, BlackRock/–∏–Ω—Å—Ç–∏—Ç—É—Ü–∏–æ–Ω–∞–ª—ã)
# –ù–æ–≤–∞—è –∫–æ–º–∞–Ω–¥–∞ /—Ç—Ä–∞–Ω—Å—Ñ–µ—Ä (–∏–ª–∏ /tx) ‚Äî –∑–∞–ø—Ä–æ—Å –∫—Ä—É–ø–Ω—ã—Ö —Å–≤–µ–∂–∏—Ö –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–π: –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å 24—á, –µ—Å–ª–∏ –Ω–µ—Ç ‚Äî –Ω–µ–¥–µ–ª—è, –º–µ—Å—è—Ü, –ø–æ–ª–≥–æ–¥–∞, –≥–æ–¥, —Å —É—Ç–æ—á–Ω–µ–Ω–∏–µ–º –ø–µ—Ä–∏–æ–¥–∞ –∏ –¥–∞—Ç
# –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ: —á–µ—Ä–µ–¥–æ–≤–∞–Ω–∏–µ —Ä–∞–∑ –≤ —á–∞—Å (–æ—Ç—á—ë—Ç ‚Üí –Ω–æ–≤–æ—Å—Ç–∏ ‚Üí –∞–ª–µ—Ä—Ç—ã ‚Üí –Ω–æ–≤–æ—Å—Ç–∏ ‚Üí —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ ‚Üí –Ω–æ–≤–æ—Å—Ç–∏ ‚Üí –∞–Ω–∞–ª–∏–∑ ‚Üí –Ω–æ–≤–æ—Å—Ç–∏ ‚Üí –∞–ª–µ—Ä—Ç—ã ‚Üí –Ω–æ–≤–æ—Å—Ç–∏ ‚Üí –æ—Ç—á—ë—Ç)
# –ù–æ–≤—ã–µ —Ñ—Ä–∞–∑—ã –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ –∫–∞–∂–¥—ã–π –±–ª–æ–∫: –æ—Ç—á—ë—Ç—ã (25+ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤), –Ω–æ–≤–æ—Å—Ç–∏ (35+ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤), –∞–ª–µ—Ä—Ç—ã (55+ FOMO), —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ (25+ —Ñ—Ä–∞–∑), –∞–Ω–∞–ª–∏–∑ (20+ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤)
# –û—Ç —Å–µ–±—è: —Ö–∞–π–ø-—Ñ–ª–∞–≥ –≤ –∞–ª–µ—Ä—Ç–∞—Ö (–µ—Å–ª–∏ –º–æ–Ω–µ—Ç–∞ –≤ —Ç–æ–ø-—Ä–æ—Å—Ç–µ + –±–æ–ª—å—à–æ–π –æ–±—ä—ë–º ‚Äî "–•–∞–π–ø –≤ —Å–æ—Ü—Å–µ—Ç—è—Ö —Ä–∞—Å—Ç—ë—Ç! üî•")
# –ü—Ä–∞–≤–∏–ª–æ 31: —Å—Ç—Ä–æ–∫–∏ > –ø—Ä–µ–¥—ã–¥—É—â–µ–π (–¥–æ–±–∞–≤–ª–µ–Ω—ã –Ω–æ–≤—ã–µ –±–ª–æ–∫–∏ —Ñ—Ä–∞–∑, –ª–æ–≥–∏, –ø—Ä–æ–≤–µ—Ä–∫–∏, –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏, handler –¥–ª—è /—Ç—Ä–∞–Ω—Å—Ñ–µ—Ä)
# –ù–æ–≤—ã–π –∞–ø–¥–µ–π—Ç –ø–æ —Ç–≤–æ–µ–º—É —Å–æ–≤–µ—Ç—É: —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –Ω–∞ —Å—É—â–Ω–æ—Å—Ç–∏ (–∫–ª–∞—Å—Å—ã), —Ä–µ–∂–∏–º—ã (normal/quiet), —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏ –Ω–∞ –¥–∏—Å–∫ (json), —É—Ä–æ–≤–Ω–∏ –¥–æ–≤–µ—Ä–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤ (üü¢/üü°/üî¥), –æ–±—ä—è—Å–Ω–∏–º—ã–µ —Å–∏–≥–Ω–∞–ª—ã

import telebot  # –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å Telegram Bot API ‚Äî –æ—Å–Ω–æ–≤–Ω–æ–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –±–æ—Ç–∞
import requests  # –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –¥–ª—è HTTP-–∑–∞–ø—Ä–æ—Å–æ–≤ –∫ –≤–Ω–µ—à–Ω–∏–º API (CoinGecko, Etherscan)
import schedule  # –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –∑–∞–¥–∞—á –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π –ø–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é
import time  # –ú–æ–¥—É–ª—å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –≤—Ä–µ–º–µ–Ω–µ–º, –ø–∞—É–∑–∞–º–∏ (sleep) –∏ —Ç–∞–π–º–∏–Ω–≥–∞–º–∏
import threading  # –î–ª—è –∑–∞–ø—É—Å–∫–∞ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ, –Ω–µ –±–ª–æ–∫–∏—Ä—É—è –æ—Å–Ω–æ–≤–Ω–æ–π polling
from datetime import datetime, timedelta  # –ö–ª–∞—Å—Å—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –¥–∞—Ç–∞–º–∏, –≤—Ä–µ–º–µ–Ω–µ–º –∏ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞–º–∏
import os  # –î–æ—Å—Ç—É–ø –∫ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º –æ–∫—Ä—É–∂–µ–Ω–∏—è (—Ç–æ–∫–µ–Ω –±–æ—Ç–∞, ID –≥—Ä—É–ø–ø—ã, Etherscan key)
import feedparser  # –ü–∞—Ä—Å–µ—Ä RSS-–ª–µ–Ω—Ç –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –Ω–æ–≤–æ—Å—Ç–µ–π –∏–∑ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤
import random  # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω—ã—Ö —á–∏—Å–µ–ª –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ñ—Ä–∞–∑, —ç–º–æ–¥–∑–∏, –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏—è –Ω–æ–≤–æ—Å—Ç–µ–π
from difflib import SequenceMatcher  # –ê–ª–≥–æ—Ä–∏—Ç–º –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ö–æ–∂–µ—Å—Ç–∏ —Å—Ç—Ä–æ–∫ (–∞–Ω—Ç–∏–¥—É–±–ª–∏ –Ω–æ–≤–æ—Å—Ç–µ–π)
from datetime import timezone  # –†–∞–±–æ—Ç–∞ —Å —á–∞—Å–æ–≤—ã–º–∏ –ø–æ—è—Å–∞–º–∏ (UTC –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è)
from deep_translator import GoogleTranslator  # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –Ω–æ–≤–æ—Å—Ç–µ–π —Å –∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æ –Ω–∞ —Ä—É—Å—Å–∫–∏–π
import json  # –î–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è/–∑–∞–≥—Ä—É–∑–∫–∏ –ø–∞–º—è—Ç–∏ –Ω–∞ –¥–∏—Å–∫

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–∞ (–∏—Å—Ç–æ—á–Ω–∏–∫: –∞–Ω–≥–ª–∏–π—Å–∫–∏–π, —Ü–µ–ª—å: —Ä—É—Å—Å–∫–∏–π) –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ EN-–Ω–æ–≤–æ—Å—Ç–µ–π
translator = GoogleTranslator(source='en', target='ru')

# –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞ –±–æ—Ç–∞ –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ–∫—Ä—É–∂–µ–Ω–∏—è (–±–µ–∑–æ–ø–∞—Å–Ω–æ), fallback –Ω–∞ –ø—É—Å—Ç–æ–π –µ—Å–ª–∏ –Ω–µ –∑–∞–¥–∞–Ω
BOT_TOKEN = os.getenv('BOT_TOKEN')

# –ü–æ–ª—É—á–µ–Ω–∏–µ ID –≥—Ä—É–ø–ø—ã —á–∞—Ç–∞ –∏–∑ env, fallback –Ω–∞ —Ç–µ—Å—Ç–æ–≤—ã–π ID –µ—Å–ª–∏ –Ω–µ –∑–∞–¥–∞–Ω
GROUP_CHAT_ID = int(os.getenv('GROUP_CHAT_ID') or '-1001922647461')

# –ü–æ–ª—É—á–µ–Ω–∏–µ API –∫–ª—é—á–∞ Etherscan –∏–∑ env (–¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π, 38-—è —Ñ–∏—à–∫–∞)
ETHERSCAN_API_KEY = os.getenv('ETHERSCAN_API_KEY')

# –°–æ–∑–¥–∞–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ –±–æ—Ç–∞ —Å –ø–æ–ª—É—á–µ–Ω–Ω—ã–º —Ç–æ–∫–µ–Ω–æ–º
bot = telebot.TeleBot(BOT_TOKEN)

# –§–∞–π–ª –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–∞–º—è—Ç–∏
MEMORY_FILE = 'bot_memory.json'

# –ö–ª–∞—Å—Å –¥–ª—è –î–∞–Ω–Ω—ã—Ö (—Å—É—â–Ω–æ—Å—Ç—å 1: –∞–≥—Ä–µ–≥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö)
class DataFetcher:
    def __init__(self):
        self.sources = [
            ("ForkLog", "https://forklog.com/feed"),
            ("Bits.media", "https://bits.media/rss/"),
            ("RBC Crypto", "https://www.rbc.ru/crypto/rss"),
            ("Cointelegraph RU", "https://cointelegraph.com/ru/rss"),
            ("BeInCrypto RU", "https://beincrypto.com/ru/rss"),
            ("Crypto.ru", "https://crypto.ru/rss"),
            ("Cointelegraph EN", "https://cointelegraph.com/rss"),
            ("Coindesk", "https://www.coindesk.com/arc/outboundfeeds/rss/"),
            ("CryptoPotato", "https://cryptopotato.com/feed/")
        ]
        self.STABLE_KEYWORDS = ['USDT', 'USDC', 'DAI', 'BUSD', 'TUSD', 'USDP', 'GUSD', 'FDUSD', 'PYUSD', 'FRAX', 'USDE', 'USD', 'BSC-USD', 'BRIDGED', 'WRAPPED', 'STETH', 'WBTC', 'CBBTC', 'WETH', 'WSTETH', 'CBETH']
        self.KNOWN_ADDRESSES = {
            '0x3f5CE5FBFe3E9af3971dD833D26bA9b5C936f0bE': 'Binance Hot Wallet 1',
            '0x28C6c06298d514Db089934071355E5743bf21d60': 'Binance Hot Wallet 2',
            '0xA9D1e08C7793af67e9d92fe308d5697FB81d3E43': 'Bybit Hot Wallet',
            '0xBeFdeeBb206C64d7c1310F8e8A3F543E71b0003f': 'BlackRock ETF Wallet',
            '0x220866b1a2219f40e72f5c628b65d54268ca3a9d': 'Vitalik Buterin (–∫–∏—Ç)',
            '0xBE0eB53F46cd790Cd13851d5EFf43D12404d33E8': 'Binance CEO Wallet',
            '0x2910543Af39abA0Cd09dBb2D50200b3E800A63D2': 'Kraken Hot Wallet',
            '0xA9D1e08C7793af67e9d92fe308d5697FB81d3E43': 'Coinbase Hot Wallet'
        }

    def is_stable(self, coin):
        symbol = coin['symbol'].upper()
        name = coin['name'].lower()
        return any(kw in symbol or kw in name for kw in self.STABLE_KEYWORDS)

    def get_crypto_data(self):
        for attempt in range(3):
            try:
                price_url = "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum,solana&vs_currencies=usd&include_24hr_change=true"
                price_data = requests.get(price_url, timeout=15).json()

                btc_price = price_data.get('bitcoin', {}).get('usd', 0)
                btc_change = round(price_data.get('bitcoin', {}).get('usd_24h_change', 0), 2)
                eth_price = price_data.get('ethereum', {}).get('usd', 0)
                eth_change = round(price_data.get('ethereum', {}).get('usd_24h_change', 0), 2)
                sol_price = price_data.get('solana', {}).get('usd', 0)
                sol_change = round(price_data.get('solana', {}).get('usd_24h_change', 0), 2)

                markets_url = "https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=250&page=1&price_change_percentage=24h"
                all_coins = requests.get(markets_url, timeout=15).json()

                filtered_coins = [coin for coin in all_coins if not self.is_stable(coin)]

                sorted_growth = sorted(filtered_coins, key=lambda x: x.get('price_change_percentage_24h', 0) or 0, reverse=True)
                sorted_drop = sorted(filtered_coins, key=lambda x: x.get('price_change_percentage_24h', 0) or 0)

                top_growth = sorted_growth[:5]
                top_drop = sorted_drop[:5]

                return {
                    'btc_price': btc_price, 'btc_change': btc_change,
                    'eth_price': eth_price, 'eth_change': eth_change,
                    'sol_price': sol_price, 'sol_change': sol_change,
                    'all_coins': filtered_coins,
                    'top_growth': top_growth,
                    'top_drop': top_drop
                }
            except Exception as e:
                print(f"–û—à–∏–±–∫–∞ CoinGecko (–ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}/3): {e}")
                time.sleep(2)
        print("–í—Å–µ –ø–æ–ø—ã—Ç–∫–∏ CoinGecko –ø—Ä–æ–≤–∞–ª–∏–ª–∏—Å—å")
        return {'all_coins': [], 'top_growth': [], 'top_drop': []}

    def get_large_transfers(self, min_value_usd=1000000, start_time=None):
        alerts = []
        eth_price = self.get_crypto_data().get('eth_price', 0)
        if eth_price == 0 or not ETHERSCAN_API_KEY:
            return []
        current_time = datetime.now()
        for address, name in self.KNOWN_ADDRESSES.items():
            params = {
                'module': 'account',
                'action': 'txlist',
                'address': address,
                'sort': 'desc',
                'apikey': ETHERSCAN_API_KEY,
                'page': 1,
                'offset': 50
            }
            try:
                response = requests.get("https://api.etherscan.io/api", params=params, timeout=10)
                data = response.json()
                if data['status'] != '1':
                    continue
                for tx in data['result']:
                    tx_time = datetime.fromtimestamp(int(tx['timeStamp']))
                    if start_time and tx_time < start_time:
                        continue
                    tx_hash = tx['hash']
                    if tx_hash in memory.last_checked_txs:
                        continue
                    value_eth = int(tx['value']) / 10**18
                    value_usd = value_eth * eth_price
                    if value_usd >= min_value_usd:
                        direction = "–í–´–í–û–î" if tx['from'].lower() == address.lower() else "–î–ï–ü–û–ó–ò–¢"
                        date_str = tx_time.strftime("%d.%m.%Y %H:%M")
                        alert = f"üêã {direction} {name}: {value_eth:.2f} ETH (${value_usd:,.0f})\n"
                        alert += random.choice(content.tx_phrases) + "\n"
                        alert += f"–î–∞—Ç–∞: {date_str}\n"
                        alert += f"–•—ç—à: https://etherscan.io/tx/{tx_hash}"
                        alerts.append(alert)
                        memory.last_checked_txs[tx_hash] = current_time
            except Exception as e:
                print(f"–û—à–∏–±–∫–∞ Etherscan –¥–ª—è {name}: {e}")
        return alerts

    def get_news(self):
        try:
            all_new_entries = []
            used_sources = set()
            for source_name, url in self.sources:
                feed = feedparser.parse(url)
                for entry in feed.entries:
                    link = entry.link
                    title = entry.title.strip()
                    if '?' in title:
                        title = title.split('?')[0].strip()
                    if "EN" in source_name or "coindesk" in url or "cryptopotato" in url:
                        try:
                            title = translator.translate(title)
                        except Exception as e:
                            print(f"–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞: {e}")
                            continue
                    if link not in memory.sent_news_urls and not any(SequenceMatcher(None, title.lower(), sent).ratio() > 0.8 for sent in memory.sent_news_titles):
                        all_new_entries.append((title, link, source_name))
                        used_sources.add(source_name)
            if not all_new_entries:
                return None
            random.shuffle(all_new_entries)
            top3 = all_new_entries[:3]
            header = random.choice(content.humor_headers)
            emojis = ["üì¢", "üî•", "üöÄ", "üí•", "üì∞", "‚ö°", "üå∂Ô∏è", "üéØ"]
            msg = f"{header}\n\n"
            memory.last_published_news = []
            for i, (title, link, source_name) in enumerate(top3):
                emoji = random.choice(emojis)
                msg += f"{emoji} {title}\n\n"
                memory.last_published_news.append((title, link))
                memory.sent_news_urls.add(link)
                memory.sent_news_titles.add(title.lower())
            if used_sources:
                msg += f"–ò—Å—Ç–æ—á–Ω–∏–∫–∏: {', '.join(used_sources)}"
            return msg
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –≤ get_news: {e}")
            return None

# –ö–ª–∞—Å—Å –¥–ª—è –ê–Ω–∞–ª–∏—Ç–∏–∫–∏ (—Å—É—â–Ω–æ—Å—Ç—å 2: –ª–æ–≥–∏–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤)
class Analytics:
    def __init__(self, mode='normal'):
        self.mode = mode  # normal, quiet, scambusters (–ø–æ–∫–∞ normal/quiet)
        self.min_monets = 2 if mode == 'normal' else 1
        self.min_change = 5
        self.min_volume_diff = 5
        self.FOMO_PHRASES = fomo_phrases
        self.ANALYSIS_COMMENTS = analysis_comments

    def get_anomaly_alerts(self):
        global big_message_id
        data = data_fetcher.get_crypto_data()
        if not data['all_coins']:
            return None
        alerts_blocks = []
        current_time = datetime.now()
        current_msk_hour = (datetime.now(timezone.utc).hour + 3) % 24
        is_night = current_msk_hour < 10 or current_msk_hour >= 22
        min_monets = 4 if is_night else self.min_monets
        # –ê–Ω–∞–ª–∏–∑ –ø—Ä–æ—à–ª—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
        past_analysis = ""
        for coin_id, info in memory.last_alerts.items():
            if isinstance(info, dict) and 'history' in info and len(info['history']) > 1:
                history = info['history']
                changes = []
                for i in range(1, len(history)):
                    prev_price = history[i-1]['price']
                    curr_price = history[i]['price']
                    if prev_price > 0:
                        changes.append((curr_price - prev_price) / prev_price * 100)
                if changes:
                    avg_change = sum(changes) / len(changes)
                    if abs(avg_change) > 5:
                        coin_name = next((c['name'] for c in data['all_coins'] if c['id'] == coin_id), coin_id.upper())
                        total_change = ((history[-1]['price'] - history[0]['price']) / history[0]['price']) * 100 if history[0]['price'] > 0 else 0
                        num_signals = len(history) - 1
                        direction = "—Ä–æ—Å—Ç" if avg_change > 0 else "–ø–∞–¥–µ–Ω–∏–µ"
                        comment = random.choice(self.ANALYSIS_COMMENTS)
                        past_analysis += f"–ü–æ –∏—Å—Ç–æ—Ä–∏–∏ {coin_name} ({num_signals} —Å–∏–≥–Ω–∞–ª–æ–≤): —Å—Ä–µ–¥–Ω–µ–µ {direction} {abs(avg_change):.2f}% –Ω–∞ —Å–∏–≥–Ω–∞–ª, –æ–±—â–∏–π {total_change:+.2f}% –æ—Ç –ø–µ—Ä–≤–æ–≥–æ. {comment}\n"
        if past_analysis:
            past_analysis = "–ê–Ω–∞–ª–∏–∑ –ø—Ä–æ—à–ª—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ (—Ç–æ–ª—å–∫–æ –∑–Ω–∞—á–∏–º—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è >5%):\n" + past_analysis + "\n"
        # –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª
        for coin in data['all_coins']:
            volume = coin.get('total_volume', 0)
            price_change = coin.get('price_change_percentage_24h', 0) or 0
            market_cap = coin.get('market_cap', 1)
            ath_change = coin.get('ath_change_percentage', 0) or 0
            price = coin.get('current_price', 0)
            coin_id = coin['id']
            if not (volume > 10000000 and market_cap > 100000000 and price > 0.001 and ath_change < -70):
                continue
            coin_data = memory.last_alerts.get(coin_id, {'history': []})
            if not isinstance(coin_data, dict):
                continue
            history = coin_data.get('history', [])
            history.append({'time': current_time, 'price': price})
            long_fomo = ""
            for entry in history[:-1]:
                time_diff = current_time - entry['time']
                days = time_diff.days
                weeks = days // 7
                months = days // 30
                if days == 0:
                    continue
                diff_percent = ((price - entry['price']) / entry['price']) * 100 if entry['price'] > 0 else 0
                if abs(diff_percent) > 20:
                    period = f"{months} –º–µ—Å—è—Ü(–∞)" if months > 0 else f"{weeks} –Ω–µ–¥–µ–ª(–∏)" if weeks > 0 else f"{days} –¥–µ–Ω—å(–¥–Ω—è)"
                    direction = "—Ä–æ—Å—Ç" if diff_percent > 0 else "–ø–∞–¥–µ–Ω–∏–µ"
                    long_fomo += f"{direction.capitalize()} –Ω–∞ {abs(diff_percent):.2f}% –∑–∞ {period} (—Å ${format_price(entry['price'])} –¥–æ ${format_price(price)})! {'–ö—Ç–æ-—Ç–æ —É–∂–µ –≤ –ø–ª—é—Å–µ ‚Äî –∞ –≤—ã?' if diff_percent > 0 else '–î–Ω–æ –±—ã–ª–æ –≥–ª—É–±–æ–∫–∏–º ‚Äî –æ—Ç—Å–∫–æ–∫ –±–ª–∏–∑–∫–æ?'}\n"
            fomo = ""
            hype_flag = ""
            if len(history) > 1:
                last_entry = history[-2]
                time_diff = current_time - last_entry['time']
                if time_diff < timedelta(hours=3):
                    history.pop()
                    continue
                price_diff = ((price - last_entry['price']) / last_entry['price']) * 100 if last_entry['price'] > 0 else 0
                last_volume = coin_data.get('last_volume', volume)
                volume_diff = ((volume - last_volume) / last_volume) * 100 if last_volume > 0 else 0
                if abs(price_diff) < self.min_change and abs(volume_diff) < self.min_volume_diff:
                    history.pop()
                    continue
                hours = time_diff.total_seconds() / 3600
                period_str = f"{int(hours)} —á–∞—Å–æ–≤" if hours < 48 else f"{int(hours // 24)} –¥–Ω–µ–π"
                price_str = f"{price_diff:+.2f}% –∑–∞ {period_str} –æ—Ç –ø—Ä–æ—à–ª–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞ (–±—ã–ª–æ ${format_price(last_entry['price'])})"
                volume_str = f"{volume_diff:+.2f}% –∑–∞ {period_str} –æ—Ç –ø—Ä–æ—à–ª–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞ (–±—ã–ª–æ ${last_volume:,})"
                status = "—Å–∏–≥–Ω–∞–ª —É—Å–∏–ª–∏–≤–∞–µ—Ç—Å—è üî•" if price_diff > 0 and volume_diff > 0 else "—Å–∏–≥–Ω–∞–ª —Å–ª–∞–±–µ–µ—Ç ‚ö†Ô∏è"
                if price_diff > 10:
                    fomo = f"–û—Ç –ø—Ä–æ—à–ª–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞ {coin['name']} —É–∂–µ +{price_diff:+.2f}% –∫ —Ü–µ–Ω–µ –∏ {volume_diff:+.2f}% –∫ –æ–±—ä—ë–º—É! –ö–∏—Ç—ã –ø—Ä–æ–¥–æ–ª–∂–∞—é—Ç –≥—Ä—É–∑–∏—Ç—å ‚Äî —ç—Ç–æ –Ω–µ —Å–ª—É—á–∞–π–Ω–æ—Å—Ç—å, —ç—Ç–æ –ø–ª–∞–Ω –ø–µ—Ä–µ–¥ –±–æ–ª—å—à–∏–º –¥–≤–∏–∂–µ–Ω–∏–µ–º.\n"
                if price_diff < -10:
                    fomo = f"–û—Ç –ø—Ä–æ—à–ª–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞ {coin['name']} {price_diff:+.2f}% –∫ —Ü–µ–Ω–µ... –ù–æ –æ–±—ä—ë–º –¥–µ—Ä–∂–∏—Ç—Å—è ‚Äî –∫–∏—Ç—ã –∂–¥—É—Ç –¥–Ω–∞ –¥–ª—è —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –∑–∞—Ö–æ–¥–∞. –û—Ç—Å–∫–æ–∫ –±—É–¥–µ—Ç –º–æ—â–Ω—ã–º!\n"
                # –•–∞–π–ø-—Ñ–ª–∞–≥
                if coin in data['top_growth'][:10] and volume > market_cap * 0.15:
                    hype_flag = "–•–∞–π–ø –≤ —Å–æ—Ü—Å–µ—Ç—è—Ö —Ä–∞—Å—Ç—ë—Ç! üî•"
            else:
                if not (-15 < price_change < 12 and volume > market_cap * 0.1):
                    history.pop()
                    continue
                price_str = f"{price_change:+.2f}% –∑–∞ 24—á"
                percent_market = round(volume / market_cap * 100)
                volume_str = f"{percent_market}% –æ—Ç –∫–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏–∏ (–æ—á–µ–Ω—å –≤—ã—Å–æ–∫–∏–π –æ–±–æ—Ä–æ—Ç!)"
                status = "–Ω–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª ‚Äî –≤–æ–∑–º–æ–∂–Ω–∞—è –∞–∫–∫—É–º—É–ª—è—Ü–∏—è!"
                # –•–∞–π–ø-—Ñ–ª–∞–≥ –¥–ª—è –Ω–æ–≤–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞
                if coin in data['top_growth'][:10] and volume > market_cap * 0.15:
                    hype_flag = "–•–∞–π–ø –≤ —Å–æ—Ü—Å–µ—Ç—è—Ö —Ä–∞—Å—Ç—ë—Ç! üî•"
            # –£—Ä–æ–≤–Ω–∏ –¥–æ–≤–µ—Ä–∏—è (–Ω–æ–≤–æ–µ: üü¢ —Å–ª–∞–±—ã–π, üü° —Å—Ä–µ–¥–Ω–∏–π, üî¥ —Å–∏–ª—å–Ω—ã–π)
            level = "üü¢ —Å–ª–∞–±—ã–π"
            if len(history) > 2 and volume > market_cap * 0.2:
                level = "üü° —Å—Ä–µ–¥–Ω–∏–π"
            if len(history) > 3 and price_change > 5 and volume_diff > 10:
                level = "üî¥ —Å–∏–ª—å–Ω—ã–π"

            value = "–ù–∞–¥—ë–∂–Ω—ã–π –∞–∫–∫—É–º—É–ª—è—Ç–æ—Ä –Ω–∞ –¥–Ω–µ ‚Äî –∫–∏—Ç—ã –≥—Ä—É–∑—è—Ç, –∂–¥—É—Ç –º–æ—â–Ω–æ–≥–æ –æ—Ç—Å–∫–æ–∫–∞. –ü–æ—è—Å–Ω–µ–Ω–∏–µ: –Ω–∞ —Ç–∞–∫–æ–º –¥–Ω–µ —Å –≤—ã—Å–æ–∫–∏–º –æ–±–æ—Ä–æ—Ç–æ–º ‚Äî –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π —Å—Ü–µ–Ω–∞—Ä–∏–π –ø–µ—Ä–µ–¥ –≤–∑–ª—ë—Ç–æ–º."
            humor = random.choice(self.FOMO_PHRASES) if not fomo else ""
            reason = f"–í—ã–±—Ä–∞–Ω –∑–∞ –æ–±—ä—ë–º {round(volume / market_cap * 100)}% –æ—Ç –∫–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏–∏ –∏ –¥–Ω–æ {ath_change:.1f}% –æ—Ç ATH. –≠—Ç–æ –∑–Ω–∞—á–∏—Ç: –∫—Ç–æ-—Ç–æ –∫—Ä—É–ø–Ω—ã–π –ø–æ–∫—É–ø–∞–µ—Ç —Ç–∏—Ö–æ, –∏–≥–Ω–æ—Ä–∏—Ä—É—è –ø–∞–Ω–∏–∫—É —Ä—ã–Ω–∫–∞."
            alert_block = f"üö® –ê–ù–û–ú–ê–õ–¨–ù–´–ô –û–ë–Å–ú ‚Äî {status} ({level}) üö®\n\n"
            alert_block += f"{coin['name']} ({coin['symbol'].upper()})\n"
            alert_block += f"–¶–µ–Ω–∞: ${format_price(price)} ({price_str})\n"
            alert_block += f"–û–±—ä—ë–º 24h: ${volume:,.0f} ({volume_str})\n"
            alert_block += f"{value}\n"
            if ath_change < -80:
                alert_block += f"–ù–∞ –¥–Ω–µ: {ath_change:.1f}% –æ—Ç ATH üî•\n"
            alert_block += f"–ü—Ä–∏—á–∏–Ω–∞ –æ—Ç–±–æ—Ä–∞: {reason}\n"
            alert_block += long_fomo
            alert_block += fomo
            alert_block += hype_flag + "\n" if hype_flag else ""
            alert_block += f"\n{humor}\n"
            alert_block += "–ü–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–∏: CoinGecko"
            alerts_blocks.append(alert_block)
            memory.last_alerts[coin_id] = {
                'last_time': current_time,
                'last_price': price,
                'last_volume': volume,
                'history': history
            }
            if len(alerts_blocks) >= 3:
                break
        if len(alerts_blocks) < min_monets:
            return None
        full_msg = "üö® –°–≤–µ–∂–∏–µ –∞–∫–∫—É–º—É–ª—è—Ç–æ—Ä—ã —Å –∞–Ω–æ–º–∞–ª—å–Ω—ã–º –æ–±—ä—ë–º–æ–º ‚Äî –∫–∏—Ç—ã –≤ –¥–µ–ª–µ! üö®\n\n"
        full_msg += "–†—ã–Ω–æ–∫ –Ω–∞ –¥–Ω–µ, –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–µ –ø—Ä–æ–µ–∫—Ç—ã –∞–∫–∫—É–º—É–ª–∏—Ä—É—é—Ç –æ–±—ä—ë–º. –≠—Ç–æ —à–∞–Ω—Å –Ω–∞ –æ—Ç—Å–∫–æ–∫. –ö—Ç–æ –≤–æ–π–¥—ë—Ç ‚Äî —Ç–æ—Ç –≤ –ø–ª—é—Å–µ. –ù–µ –±—É–¥—å—Ç–µ —Ç–µ–º, –∫—Ç–æ '–∂–¥–∞–ª –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è' –≤ 2022. –†—É–±–ª—å –Ω–∞ –≤–µ—Ä—É ‚Äî –∏ –≤—ã –ª–µ–≥–µ–Ω–¥–∞ üòè\n\n"
        full_msg += past_analysis
        full_msg += "\n\n".join(alerts_blocks)
        try:
            sent = bot.send_message(GROUP_CHAT_ID, full_msg, reply_to_message_id=big_message_id, disable_web_page_preview=True)
            big_message_id = sent.message_id
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∞–ª–µ—Ä—Ç–∞: {e}")
        return full_msg

# –ö–ª–∞—Å—Å –¥–ª—è –ü–∞–º—è—Ç–∏ (—Å—É—â–Ω–æ—Å—Ç—å 3: —Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è)
class Memory:
    def __init__(self):
        self.last_alerts = {}
        self.last_checked_txs = {}
        self.sent_news_urls = set()
        self.sent_news_titles = set()
        self.last_published_news = []
        self.last_daily_report_date = None
        self.last_final_report_date = None
        self.load_from_disk()

    def load_from_disk(self):
        if os.path.exists(MEMORY_FILE):
            with open(MEMORY_FILE, 'r') as f:
                data = json.load(f)
                self.last_alerts = data.get('last_alerts', {})
                self.last_checked_txs = data.get('last_checked_txs', {})
                self.sent_news_urls = set(data.get('sent_news_urls', []))
                self.sent_news_titles = set(data.get('sent_news_titles', []))
                self.last_published_news = data.get('last_published_news', [])
                self.last_daily_report_date = data.get('last_daily_report_date')
                self.last_final_report_date = data.get('last_final_report_date')
            print("–ü–∞–º—è—Ç—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞ —Å –¥–∏—Å–∫–∞")

    def save_to_disk(self):
        data = {
            'last_alerts': self.last_alerts,
            'last_checked_txs': self.last_checked_txs,
            'sent_news_urls': list(self.sent_news_urls),
            'sent_news_titles': list(self.sent_news_titles),
            'last_published_news': self.last_published_news,
            'last_daily_report_date': self.last_daily_report_date,
            'last_final_report_date': self.last_final_report_date
        }
        with open(MEMORY_FILE, 'w') as f:
            json.dump(data, f)
        print("–ü–∞–º—è—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –Ω–∞ –¥–∏—Å–∫")

# –ö–ª–∞—Å—Å –¥–ª—è –ö–æ–Ω—Ç–µ–Ω—Ç–∞ (—Å—É—â–Ω–æ—Å—Ç—å 4: —Ñ—Ä–∞–∑—ã, –∑–∞–≥–æ–ª–æ–≤–∫–∏)
class ContentGenerator:
    def __init__(self):
        self.daily_report_titles = daily_report_titles
        self.final_report_phrases = final_report_phrases
        self.fomo_phrases = fomo_phrases
        self.humor_headers = humor_headers
        self.tx_phrases = tx_phrases
        self.analysis_comments = analysis_comments

# –ö–ª–∞—Å—Å –¥–ª—è –î–æ—Å—Ç–∞–≤–∫–∏ (—Å—É—â–Ω–æ—Å—Ç—å 5: Telegram, —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ)
class Delivery:
    def __init__(self, bot, group_id):
        self.bot = bot
        self.group_id = group_id
        self.big_message_id = None

    def send_message(self, msg, reply_id=None):
        try:
            sent = self.bot.send_message(self.group_id, msg, reply_to_message_id=reply_id, disable_web_page_preview=True)
            self.big_message_id = sent.message_id
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: {e}")

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—É—â–Ω–æ—Å—Ç–µ–π
data_fetcher = DataFetcher()
analytics = Analytics(mode='normal')  # –ú–æ–∂–Ω–æ –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –Ω–∞ 'quiet' –¥–ª—è –º–µ–Ω—å—à–µ–≥–æ —Å–ø–∞–º–∞
memory = Memory()
content = ContentGenerator()
delivery = Delivery(bot, GROUP_CHAT_ID)

# –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏ –Ω–∞ –¥–∏—Å–∫ —Ä–∞–∑ –≤ 10 –º–∏–Ω
def save_memory_task():
    memory.save_to_disk()

schedule.every(10).minutes.do(save_memory_task)

# –ê–¥–∞–ø—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
def get_top_cap(n=10):
    data = data_fetcher.get_crypto_data()
    if not data['all_coins']:
        return "‚ö†Ô∏è –ü—Ä–æ–±–ª–µ–º–∞ —Å –¥–∞–Ω–Ω—ã–º–∏ ‚Äî –ø–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ"
    msg = f"üèÜ –¢–æ–ø-{n} –ø–æ –∫–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏–∏ (–±–µ–∑ —Å—Ç–µ–π–±–ª–æ–≤):\n\n"
    sorted_cap = sorted(data['all_coins'], key=lambda x: x.get('market_cap', 0) or 0, reverse=True)[:n]
    for i, coin in enumerate(sorted_cap, 1):
        msg += f"{i}. {coin['name']} ({coin['symbol'].upper()}) ‚Äî ${coin['market_cap']:,.0f} ({format_price(coin['current_price'])})\n"
    msg += "\n–ò—Å—Ç–æ—á–Ω–∏–∫: CoinGecko"
    return msg

def get_top_growth(n=10):
    data = data_fetcher.get_crypto_data()
    if not data['all_coins']:
        return "‚ö†Ô∏è –ü—Ä–æ–±–ª–µ–º–∞ —Å –¥–∞–Ω–Ω—ã–º–∏ ‚Äî –ø–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ"
    msg = f"üöÄ –¢–æ–ø-{n} —Ä–æ—Å—Ç–∞ –∑–∞ 24—á:\n\n"
    sorted_growth = sorted(data['all_coins'], key=lambda x: x.get('price_change_percentage_24h', 0) or 0, reverse=True)[:n]
    for i, coin in enumerate(sorted_growth, 1):
        change = coin.get('price_change_percentage_24h', 0)
        msg += f"{i}. {coin['name']} ({coin['symbol'].upper()}) ‚Äî {change:+.2f}% ({format_price(coin['current_price'])})\n"
    msg += "\n–ò—Å—Ç–æ—á–Ω–∏–∫: CoinGecko"
    return msg

def get_top_drop(n=10):
    data = data_fetcher.get_crypto_data()
    if not data['all_coins']:
        return "‚ö†Ô∏è –ü—Ä–æ–±–ª–µ–º–∞ —Å –¥–∞–Ω–Ω—ã–º–∏ ‚Äî –ø–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ"
    msg = f"üìâ –¢–æ–ø-{n} –ø–∞–¥–µ–Ω–∏—è –∑–∞ 24—á:\n\n"
    sorted_drop = sorted(data['all_coins'], key=lambda x: x.get('price_change_percentage_24h', 0) or 0)[:n]
    for i, coin in enumerate(sorted_drop, 1):
        change = coin.get('price_change_percentage_24h', 0)
        msg += f"{i}. {coin['name']} ({coin['symbol'].upper()}) ‚Äî {change:+.2f}% ({format_price(coin['current_price'])})\n"
    msg += "\n–ò—Å—Ç–æ—á–Ω–∏–∫: CoinGecko"
    return msg

def create_daily_report():
    data = data_fetcher.get_crypto_data()
    if not data['all_coins']:
        return "‚ö†Ô∏è –ü—Ä–æ–±–ª–µ–º–∞ —Å –¥–∞–Ω–Ω—ã–º–∏ ‚Äî –æ—Ç—á—ë—Ç –ø–æ–∑–∂–µ"
    title = random.choice(content.daily_report_titles)
    msg = f"{title}\n\n"
    msg += "–û—Å–Ω–æ–≤–Ω—ã–µ:\n"
    msg += f"üü† BTC: ${data['btc_price']:,} {data['btc_change']:+.2f}%\n"
    msg += f"üî∑ ETH: ${data['eth_price']:,} {data['eth_change']:+.2f}%\n"
    msg += f"üü£ SOL: ${data['sol_price']:,} {data['sol_change']:+.2f}%\n\n"
    msg += "üöÄ –¢–æ–ø-3 —Ä–æ—Å—Ç–∞:\n"
    for i, coin in enumerate(data['top_growth'][:3], 1):
        change = coin.get('price_change_percentage_24h', 0)
        msg += f"{i}. {coin['name']} ({coin['symbol'].upper()}) ‚Äî {change:+.2f}% ({format_price(coin['current_price'])})\n"
    msg += "\nüìâ –¢–æ–ø-3 –ø–∞–¥–µ–Ω–∏—è:\n"
    for i, coin in enumerate(data['top_drop'][:3], 1):
        change = coin.get('price_change_percentage_24h', 0)
        msg += f"{i}. {coin['name']} ({coin['symbol'].upper()}) ‚Äî {change:+.2f}% ({format_price(coin['current_price'])})\n"
    msg += "\n–ò—Å—Ç–æ—á–Ω–∏–∫: CoinGecko"
    return msg

def final_day_report():
    data = data_fetcher.get_crypto_data()
    if not data['all_coins']:
        return "‚ö†Ô∏è –ü—Ä–æ–±–ª–µ–º–∞ —Å –¥–∞–Ω–Ω—ã–º–∏ ‚Äî —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç—á—ë—Ç –ø–æ–∑–∂–µ"
    msg = "üìä –§–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç—á—ë—Ç –∑–∞ –¥–µ–Ω—å ‚Äî –ª–∏–¥–µ—Ä—ã —Ä–æ—Å—Ç–∞ –∏ –¥–Ω–∞:\n\n"
    msg += "üöÄ –¢–æ–ø-5 —Ä–æ—Å—Ç–∞ –∑–∞ 24—á:\n"
    for i, coin in enumerate(data['top_growth'], 1):
        change = coin.get('price_change_percentage_24h', 0)
        msg += f"{i}. {coin['name']} ({coin['symbol'].upper()}) ‚Äî {change:+.2f}% ({format_price(coin['current_price'])})\n"
    msg += "\nüìâ –¢–æ–ø-5 –ø–∞–¥–µ–Ω–∏—è –∑–∞ 24—á:\n"
    for i, coin in enumerate(data['top_drop'], 1):
        change = coin.get('price_change_percentage_24h', 0)
        msg += f"{i}. {coin['name']} ({coin['symbol'].upper()}) ‚Äî {change:+.2f}% ({format_price(coin['current_price'])})\n"
    msg += f"\n{random.choice(content.final_report_phrases)}"
    msg += "\n–ò—Å—Ç–æ—á–Ω–∏–∫: CoinGecko"
    return msg

def send_past_analysis():
    data = data_fetcher.get_crypto_data()
    current_time = datetime.now()
    msg = "üìà –ê–Ω–∞–ª–∏–∑ –ø—Ä–æ—à–ª—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ –∑–∞ –Ω–µ–¥–µ–ª—é (—Ç–æ–ª—å–∫–æ –∑–Ω–∞—á–∏–º—ã–µ >5%):\n\n"
    found = False
    for coin_id, info in memory.last_alerts.items():
        if isinstance(info, dict) and 'history' in info and len(info['history']) > 1:
            history = info['history']
            week_ago = current_time - timedelta(days=7)
            week_history = [h for h in history if h['time'] > week_ago]
            if len(week_history) > 1:
                first_price = week_history[0]['price']
                last_price = week_history[-1]['price']
                change = ((last_price - first_price) / first_price) * 100 if first_price > 0 else 0
                if abs(change) > 5:
                    coin_name = next((c['name'] for c in data['all_coins'] if c['id'] == coin_id), coin_id.upper())
                    direction = "—Ä–æ—Å—Ç" if change > 0 else "–ø–∞–¥–µ–Ω–∏–µ"
                    comment = random.choice(content.analysis_comments)
                    msg += f"{coin_name}: {abs(change):.2f}% {direction} –∑–∞ –Ω–µ–¥–µ–ª—é (—Å ${format_price(first_price)} –¥–æ ${format_price(last_price)}). {comment}\n"
                    found = True
    if found:
        msg += "\n–ü–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–∏: CoinGecko"
        try:
            bot.send_message(GROUP_CHAT_ID, msg)
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∞–Ω–∞–ª–∏–∑–∞: {e}")

# –ö–æ–º–∞–Ω–¥—ã –±–æ—Ç–∞
@bot.message_handler(commands=['—Å—Å—ã–ª–∫–∞'])
def handle_links(message):
    if not memory.last_published_news:
        bot.send_message(message.chat.id, "–ü–æ—Å–ª–µ–¥–Ω–∏—Ö –Ω–æ–≤–æ—Å—Ç–µ–π –ø–æ–∫–∞ –Ω–µ—Ç ‚Äî –ø–æ–ø—Ä–æ–±—É–π /–Ω–æ–≤–æ—Å—Ç–∏.")
        return
    msg = "–°—Å—ã–ª–∫–∏ –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–∏:\n\n"
    for i, (title, link) in enumerate(memory.last_published_news, 1):
        msg += f"{i}. {title}\n{link}\n\n"
    bot.send_message(message.chat.id, msg)

@bot.message_handler(commands=['–∫—É—Ä—Å'])
def handle_kurs(message):
    bot.send_message(message.chat.id, create_daily_report())

@bot.message_handler(commands=['—Ç–æ–ø'])
def handle_top(message):
    bot.send_message(message.chat.id, get_top_cap(10))

@bot.message_handler(commands=['—Ä–æ—Å—Ç'])
def handle_growth(message):
    bot.send_message(message.chat.id, get_top_growth(10))

@bot.message_handler(commands=['–ø–∞–¥–µ–Ω–∏–µ'])
def handle_drop(message):
    bot.send_message(message.chat.id, get_top_drop(10))

@bot.message_handler(commands=['–∞–ª–µ—Ä—Ç'])
def handle_alert(message):
    alert = analytics.get_anomaly_alerts()
    if alert:
        bot.send_message(message.chat.id, alert, disable_web_page_preview=True)
    else:
        bot.send_message(message.chat.id, "üò¥ –°–µ–π—á–∞—Å –Ω–µ—Ç –∑–Ω–∞—á–∏–º—ã—Ö –∞–Ω–æ–º–∞–ª–∏–π ‚Äî —Ä—ã–Ω–æ–∫ —Å–ø–æ–∫–æ–π–Ω—ã–π.")

@bot.message_handler(commands=['–Ω–æ–≤–æ—Å—Ç–∏'])
def handle_news(message):
    news = data_fetcher.get_news()
    if news:
        bot.send_message(message.chat.id, news, disable_web_page_preview=False)
    else:
        bot.send_message(message.chat.id, "‚ö†Ô∏è –ù–µ—Ç –Ω–æ–≤—ã—Ö –Ω–æ–≤–æ—Å—Ç–µ–π ‚Äî –ø–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ")

@bot.message_handler(commands=['–ø–æ–º–æ—â—å', 'help'])
def handle_help(message):
    help_text = """
ü§ñ *–ö—Ä–∏–ø—Ç–æ–ê–°–ò–°–¢ ‚Äî —Ç–≤–æ—è –∫—Ä–∏–ø—Ç–æ—à–∫–æ–ª–∞ –≤ '–ö—Ä–∏–ø—Ç–æ–±–æ–º–∂–∞—Ö'*
–ö–æ–º–∞–Ω–¥—ã:
‚Ä¢ /–∫—É—Ä—Å ‚Äî –æ—Ç—á—ë—Ç –ø–æ —Ä—ã–Ω–∫—É
‚Ä¢ /—Ç–æ–ø ‚Äî —Ç–æ–ø –∫–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏–∏
‚Ä¢ /—Ä–æ—Å—Ç ‚Äî —Ç–æ–ø —Ä–æ—Å—Ç–∞
‚Ä¢ /–ø–∞–¥–µ–Ω–∏–µ ‚Äî —Ç–æ–ø –ø–∞–¥–µ–Ω–∏—è
‚Ä¢ /–∞–ª–µ—Ä—Ç ‚Äî –∞–Ω–æ–º–∞–ª–∏–∏ —Å –∞–Ω–∞–ª–∏–∑–æ–º
‚Ä¢ /–Ω–æ–≤–æ—Å—Ç–∏ ‚Äî —Å–≤–µ–∂–∏–µ –Ω–æ–≤–æ—Å—Ç–∏ –∫—Ä–∏–ø—Ç—ã
‚Ä¢ /—Å—Å—ã–ª–∫–∞ ‚Äî —Å—Å—ã–ª–∫–∏ –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–∏
‚Ä¢ /—Ç—Ä–∞–Ω—Å—Ñ–µ—Ä –∏–ª–∏ /tx ‚Äî –∫—Ä—É–ø–Ω—ã–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è (24—á ‚Üí –Ω–µ–¥–µ–ª—è ‚Üí –º–µ—Å—è—Ü ‚Üí –ø–æ–ª–≥–æ–¥–∞ ‚Üí –≥–æ–¥)
‚Ä¢ /–ø–æ–º–æ—â—å ‚Äî —ç—Ç–æ

–°–∏–≥–Ω–∞–ª—ã —Å FOMO ‚Äî –Ω–µ –ø—Ä–æ—Å–ø–∏ –ø–∞–º–ø! üòà
"""
    bot.send_message(message.chat.id, help_text)

@bot.message_handler(commands=['—Ç—Ä–∞–Ω—Å—Ñ–µ—Ä', 'tx'])
def handle_transfer(message):
    periods = [
        ("–∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 24 —á–∞—Å–∞", timedelta(hours=24)),
        ("–∑–∞ –ø–æ—Å–ª–µ–¥–Ω—é—é –Ω–µ–¥–µ–ª—é", timedelta(days=7)),
        ("–∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–π –º–µ—Å—è—Ü", timedelta(days=30)),
        ("–∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ –ø–æ–ª–≥–æ–¥–∞", timedelta(days=182)),
        ("–∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–π –≥–æ–¥", timedelta(days=365))
    ]
    for period_name, delta in periods:
        start_time = datetime.now() - delta
        txs = data_fetcher.get_large_transfers(min_value_usd=1000000, start_time=start_time)
        if txs:
            report = f"üî• –ö—Ä—É–ø–Ω—ã–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ {period_name}:\n\n" + "\n\n".join(txs[:10])
            bot.send_message(message.chat.id, report)
            return
    bot.send_message(message.chat.id, "üò¥ –ó–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–π –≥–æ–¥ –∫—Ä—É–ø–Ω—ã—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π (> $1M) –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")

# –ó–∞–¥–∞—á–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è
def daily_report_task():
    if memory.last_daily_report_date == datetime.now().date():
        print("–£—Ç—Ä–µ–Ω–Ω–∏–π –æ—Ç—á—ë—Ç —É–∂–µ –±—ã–ª ‚Äî –ø—Ä–æ–ø—É—Å–∫")
        return
    msg = create_daily_report()
    delivery.send_message(msg)
    memory.last_daily_report_date = datetime.now().date()

def final_report_task():
    if memory.last_final_report_date == datetime.now().date():
        print("–§–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç—á—ë—Ç —É–∂–µ –±—ã–ª ‚Äî –ø—Ä–æ–ø—É—Å–∫")
        return
    msg = final_day_report()
    delivery.send_message(msg)
    memory.last_final_report_date = datetime.now().date()

def send_alerts():
    msg = analytics.get_anomaly_alerts()
    if msg:
        delivery.send_message(msg, delivery.big_message_id)

def send_news_task():
    msg = data_fetcher.get_news()
    if msg:
        delivery.send_message(msg)

def send_transaction_alerts():
    txs = data_fetcher.get_large_transfers()
    if txs:
        for alert in txs:
            delivery.send_message(alert)

# –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ
def run_scheduler():
    schedule.every().day.at("07:00").do(daily_report_task)
    schedule.every().day.at("08:00").do(send_news_task)
    schedule.every().day.at("09:00").do(send_alerts)
    schedule.every().day.at("10:00").do(send_news_task)
    schedule.every().day.at("11:00").do(send_transaction_alerts)
    schedule.every().day.at("12:00").do(send_news_task)
    schedule.every().day.at("13:00").do(send_past_analysis)
    schedule.every().day.at("14:00").do(send_news_task)
    schedule.every().day.at("15:00").do(send_alerts)
    schedule.every().day.at("16:00").do(send_news_task)
    schedule.every().day.at("17:00").do(final_report_task)
    while True:
        schedule.run_pending()
        time.sleep(1)

# –ó–∞–ø—É—Å–∫
if __name__ == '__main__':
    print("–ö—Ä–∏–ø—Ç–æ–ê–°–ò–°–¢ –≤–µ—Ä—Å–∏—è 38.1 –æ–∂–∏–ª! üòà –° –Ω–æ–≤–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π.")
    bot.remove_webhook()
    try:
        alive_msg = bot.send_message(GROUP_CHAT_ID, "–ö—Ä–∏–ø—Ç–æ–ê–°–ò–°–¢ –æ–∂–∏–ª! üòà –í–µ—Ä—Å–∏—è 38.1 ‚Äî —Ç–µ–ø–µ—Ä—å —Å —Ä–µ–∂–∏–º–∞–º–∏ –∏ –ø–∞–º—è—Ç—å—é –Ω–∞ –¥–∏—Å–∫–µ!")
        bot.send_message(GROUP_CHAT_ID, "–ë–æ–º–∂–∞–º –ø—Ä–∏–≤–µ—Ç! üëæ", reply_to_message_id=alive_msg.message_id)
    except Exception as e:
        print(f"–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –Ω–µ —É—à–ª–æ: {e}")

    threading.Thread(target=run_scheduler, daemon=True).start()

    while True:
        try:
            bot.infinity_polling(none_stop=True)
        except Exception as e:
            print(f"Polling —É–ø–∞–ª: {e}. –†–µ—Å—Ç–∞—Ä—Ç —á–µ—Ä–µ–∑ 10 —Å–µ–∫...")
            time.sleep(10)
